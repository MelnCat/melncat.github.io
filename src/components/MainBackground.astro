<div class="bg">
	<div class="overlay">
		<canvas id="bgCanvas"></canvas>
	</div>
	<slot />
</div>

<script>
	const canvas = document.getElementById("bgCanvas") as HTMLCanvasElement;
	canvas.width = canvas.clientWidth;
	canvas.height = canvas.clientHeight;

	const ctx = canvas.getContext("2d")!;
	const rand = (min: number, max: number) => Math.random() * (max - min) + min;

	const objs = new Set<{ x: number; y: number; z: number; vx: number; vy: number }>();
	for (let i = 0; i < (300 * canvas.height) / 1000; i++) {
		objs.add({ x: rand(-100, canvas.width + 100), y: rand(-100, canvas.height + 100), z: rand(0, 1), vx: 0, vy: 0 });
	}

	let last = 0;
	let mouseX = sessionStorage.mouseX ? +sessionStorage.mouseX : 0;
	let mouseY = sessionStorage.mouseY ? +sessionStorage.mouseY : 0;
	if (window.matchMedia("(hover: hover)").matches) {
		document.addEventListener("mousemove", e => {
			mouseX = e.x;
			mouseY = e.y;
			sessionStorage.mouseX = mouseX;
			sessionStorage.mouseY = mouseY;
		});
	}

	const render = (t: number) => {
		const dt = t - last;
		last = t;

		ctx.globalCompositeOperation = "source-over";

		const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
		gradient.addColorStop(0, "#111111");
		gradient.addColorStop(0.3, "#223172");
		gradient.addColorStop(0.6, "#c76569");
		gradient.addColorStop(1, "#e29051");

		ctx.fillStyle = gradient;

		ctx.fillRect(0, 0, canvas.width, canvas.height);

		//ctx.globalCompositeOperation = "soft-light";
		for (const obj of objs) {
			obj.x += (obj.vx * dt) / 2;
			obj.y += (obj.vy * dt) / 2;
			ctx.strokeStyle = `#ffffff${Math.floor(0x100 * obj.z)
				.toString(16)
				.padStart(2, "0")}`;
			const s = 7 * obj.z + 3;
			ctx.lineWidth = 2;
			const scaleZ = 1 - obj.z;
			const parallaxY = scaleZ * (scrollY + (mouseY / screenY - 0.5) * 0.2);
			const parallaxX = scaleZ * (mouseX / screenX - 0.5) * 0.2;
			ctx.beginPath();
			ctx.moveTo(obj.x + parallaxX - s, obj.y + parallaxY);
			ctx.lineTo(obj.x + parallaxX + s, obj.y + parallaxY);
			ctx.stroke();
			ctx.closePath();
			ctx.beginPath();
			ctx.moveTo(obj.x + parallaxX, obj.y + parallaxY - s);
			ctx.lineTo(obj.x + parallaxX, obj.y + parallaxY + s);
			ctx.stroke();
			ctx.closePath();

			if (obj.y > canvas.height) objs.delete(obj);
		}
		requestAnimationFrame(render);
	};

	render(0);

	setInterval(() => {
		const angle = rand(0, Math.PI);
		objs.add({ x: rand(0, canvas.width), y: -10, z: rand(0, 1), vx: Math.cos(angle), vy: Math.sin(angle) });
	}, 5000);
</script>

<style>
	.bg {
		height: 100%;
		flex-grow: 1;
		position: relative;
		background-image: linear-gradient(#111111, #223172 30%, #c76569 60%, #e29051);
		display: flex;
		flex-direction: column;
		z-index: 0;
	}
	#bgCanvas {
		width: 100%;
		height: 100%;
	}
	.overlay {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: -1;
	}
</style>

<script
